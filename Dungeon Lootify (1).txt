-- Kapao Hub UI with Kill Aura Integration (Fixed)
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Initialize Kill Aura Config
getgenv().KapaoConfig = getgenv().KapaoConfig or {
    KillAura_Enabled = false,
    KillAura_Range = 1500,
    KillAura_MaxTargets = 3,
    KillAura_Mode = 'both',
    KillAura_PredictiveAim = true,
    KillAura_PredictionTime = 0.12,
    KillAura_TeleportEnabled = false,
    KillAura_TeleportRange = 50,
    KillAura_TeleportHeight = 30,
    KillAura_HoverEnabled = false,
    
    -- Auto Farm Defaults
    AutoFarm_Enabled = false,
    AutoFarm_AntiSit = true,
    AutoFarm_Noclip = true,
    AutoFarm_AutoChest = true,
    AutoFarm_AutoRetry = true,
    AutoFarm_ChestDelay = 0.4,
    AutoFarm_RoomClearDelay = 0.4,
    AutoFarm_TweenSpeed = 0.3,
    AutoFarm_Hover = false,
    AutoFarm_HoverHeight = 15,

    -- Misc
    AutoHeal_Enabled = false,
    DupeWeapons_Enabled = false,
    AutoSell_Enabled = false,
    FixStuckLoading_Enabled = false,
}

-- Auto Heal allowed PlaceID
local AUTOHEAL_ALLOWED_PLACE = 120876398824321
local FARM_PLACE_ID = 120876398824321

local function isAutoHealAllowed()
    return game.PlaceId == AUTOHEAL_ALLOWED_PLACE
end


-- Create Window
local Window = Fluent:CreateWindow({
    Title = "Kapao Hub " .. Fluent.Version,
    SubTitle = "Happy Burnout Syndrome ;w;",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.RightControl
})

-- Services
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local ReplicatedFirst = game:GetService('ReplicatedFirst')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local ContentProvider = game:GetService('ContentProvider')
local RunService = game:GetService('RunService')
local CollectionService = game:GetService('CollectionService')
local UserInputService = game:GetService('UserInputService')

-- Wait for game to load
if not game:IsLoaded() then
    game.Loaded:Wait()
end

local LP = Players.LocalPlayer or Players.PlayerAdded:Wait()

-- Helper function to wait for things
local function waitFor(pred, timeout)
    local t0 = os.clock()
    timeout = timeout or 30
    while os.clock() - t0 < timeout do
        local ok, v = pcall(pred)
        if ok and v then
            return v
        end
        task.wait(0.05)
    end
end

-- Create Logo in top-left corner
spawn(function()
    wait(0.5)
    local screenGui = Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChild("ScreenGui") or CoreGui:FindFirstChildOfClass("ScreenGui")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    
    if screenGui then
        -- Logo Frame (Make it a button)
        local logoButton = Instance.new("TextButton")
        logoButton.Name = "KapaoLogo"
        logoButton.Size = UDim2.new(0, 160, 0, 160)
        logoButton.Position = UDim2.new(0, 10, 0, 10)
        logoButton.BackgroundTransparency = 1
        logoButton.Text = ""
        logoButton.Parent = screenGui
        
        -- Logo Image
        local logoImage = Instance.new("ImageLabel")
        logoImage.Name = "Logo"
        logoImage.Size = UDim2.new(1, 0, 1, 0)
        logoImage.Position = UDim2.new(0, 0, 0, 0)
        logoImage.BackgroundTransparency = 1
        logoImage.Image = "rbxassetid://129672522731097"
        logoImage.ScaleType = Enum.ScaleType.Fit
        logoImage.Parent = logoButton
        
        -- Add shadow/glow effect
        local logoGlow = Instance.new("ImageLabel")
        logoGlow.Name = "Glow"
        logoGlow.Size = UDim2.new(1.2, 0, 1.2, 0)
        logoGlow.Position = UDim2.new(-0.1, 0, -0.1, 0)
        logoGlow.BackgroundTransparency = 1
        logoGlow.Image = "rbxassetid://129672522731097"
        logoGlow.ImageTransparency = 0.7
        logoGlow.ScaleType = Enum.ScaleType.Fit
        logoGlow.ZIndex = 0
        logoGlow.Parent = logoButton
        
        -- Drag support for logo
        local dragging = false
        local dragStart
        local startPos

        local function clampToScreen(pos)
            local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
            local x = math.clamp(pos.X, 0, vp.X - logoButton.AbsoluteSize.X)
            local y = math.clamp(pos.Y, 0, vp.Y - logoButton.AbsoluteSize.Y)
            return UDim2.fromOffset(x, y)
        end

        logoButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
                dragStart = input.Position
                startPos = logoButton.AbsolutePosition
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)

        UserInputService.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local delta = input.Position - dragStart
                local newPos = Vector2.new(startPos.X + delta.X, startPos.Y + delta.Y)
                logoButton.Position = clampToScreen(newPos)
            end
        end)

        -- Breathing animation for logo
        local breatheTween = TweenService:Create(
            logoImage,
            TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true),
            {Size = UDim2.new(1.05, 0, 1.05, 0), Position = UDim2.new(-0.025, 0, -0.025, 0)}
        )
        breatheTween:Play()
        
        -- Logo click to send Left Ctrl key
        logoButton.MouseButton1Click:Connect(function()
            -- Simulate Left Ctrl key press
            if VirtualInputManager then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
                wait(0.05)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftControl, false, game)
            else
                -- Fallback method using keypress
                game:GetService("VirtualUser"):SetKeyDown(Enum.KeyCode.LeftControl)
                wait(0.05)
                game:GetService("VirtualUser"):SetKeyUp(Enum.KeyCode.LeftControl)
            end
            
            -- Animate logo on click
            local clickTween = TweenService:Create(
                logoImage,
                TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
                {Size = UDim2.new(0.9, 0, 0.9, 0), Position = UDim2.new(0.05, 0, 0.05, 0)}
            )
            clickTween:Play()
            wait(0.1)
            local releaseTween = TweenService:Create(
                logoImage,
                TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut),
                {Size = UDim2.new(1, 0, 1, 0), Position = UDim2.new(0, 0, 0, 0)}
            )
            releaseTween:Play()
        end)
        
        -- Hover effect for logo
        logoButton.MouseEnter:Connect(function()
            TweenService:Create(
                logoGlow,
                TweenInfo.new(0.2),
                {ImageTransparency = 0.5}
            ):Play()
        end)
        
        logoButton.MouseLeave:Connect(function()
            TweenService:Create(
                logoGlow,
                TweenInfo.new(0.2),
                {ImageTransparency = 0.7}
            ):Play()
        end)
    end
end)

-- Mobile Toggle Button removed per request

-- Create Tabs
local Tabs = {
    Combat = Window:AddTab({ Title = "⚔️ Combat", Icon = "" }),
    AutoFarm = Window:AddTab({ Title = "🗺️ Auto Farm", Icon = "" }),
    Misc = Window:AddTab({ Title = "🧰 Misc", Icon = "" }),
    Settings = Window:AddTab({ Title = "⚙️ Settings", Icon = "" })
}

local Options = Fluent.Options

-- Kill Aura System (Fixed Version)
local RESTRICTED_PLACE_IDS = {
    [72607172956362] = false,
    [124216767173297] = false,
}

local function isRestrictedPlace()
    return RESTRICTED_PLACE_IDS[game.PlaceId] == true
end

local KillAuraSystem = {}
KillAuraSystem.Enabled = false

function KillAuraSystem:Start()
    if self.Enabled then return end
    if not isAutoHealAllowed() then
        return
    end

    self.Enabled = true

    -- Wait for TNetSent to be available
    local TNet
    local attempts = 0
    repeat
        TNet = ReplicatedStorage:FindFirstChild('TNetSent')
        if not TNet then
            attempts = attempts + 1
            if attempts > 100 then -- 10 seconds timeout
                self.Enabled = false
                return
            end
            task.wait(0.1)
        end
    until TNet

    local attackCounter = 0
    local enemyData = {} 
    local lastUpdateTime = tick()

    local ATTACK_PROFILES = {
        DuoSword = { weaponName = 'DuoSword' },
        SwordShield = { weaponName = 'SwordShield' },
        Wood = { weaponName = 'Wood' },
    }
    local DEFAULT_WEAPON_AUTO = 'SwordShield'

    local function HRP()
        local ch = LP.Character
        return ch and ch:FindFirstChild('HumanoidRootPart')
    end

    local function findMobHRP(model)
        for _, d in ipairs(model:GetDescendants()) do
            if d:IsA('BasePart') and d.Name == 'HumanoidRootPart' then
                return d
            end
        end
    end

    local function isAlive(model)
        if not model or not model.Parent then return false end
        if model:GetAttribute('Died') then return false end 
        local hum = model:FindFirstChildOfClass('Humanoid')
        local r = findMobHRP(model)
        return hum and r and hum.Health > 0
    end
    
    -- Enhanced enemy detection that checks current room
    local function getCurrentRoom()
        local char = LP.Character
        if not char then return nil end
        
        local currentRoomUUID = char:GetAttribute('CurrentRoom')
        if not currentRoomUUID then return nil end
        
        for _, model in workspace:GetChildren() do
            if model:IsA('Model') and model:GetAttribute('UUID') == currentRoomUUID then
                return model
            end
        end
        return nil
    end
    
    local function getActiveEnemies()
        local list = {}
        
        -- First, check current room for enemies
        local room = getCurrentRoom()
        if room then
            -- Search for enemies in current room
            for _, child in ipairs(room:GetDescendants()) do
                if child:IsA('Model') and child ~= room then
                    if isAlive(child) then
                        local hum = child:FindFirstChildOfClass('Humanoid')
                        local hrp = findMobHRP(child)
                        if hum and hrp then
                            table.insert(list, child)
                        end
                    end
                end
            end
        end
        
        -- Also check tagged enemies (global search)
        for _, m in ipairs(CollectionService:GetTagged('Enemy')) do
            if isAlive(m) then 
                local alreadyAdded = false
                for _, existing in ipairs(list) do
                    if existing == m then
                        alreadyAdded = true
                        break
                    end
                end
                if not alreadyAdded then
                    table.insert(list, m)
                end
            end
        end
        
        -- Check EndlessScene
        local endlessScene = workspace:FindFirstChild('EndlessScene')
        if endlessScene then
            for _, m in ipairs(endlessScene:GetChildren()) do
                if m:IsA('Model') and m.Name ~= 'Enemy' and isAlive(m) then 
                    local alreadyAdded = false
                    for _, existing in ipairs(list) do
                        if existing == m then
                            alreadyAdded = true
                            break
                        end
                    end
                    if not alreadyAdded then
                        table.insert(list, m)
                    end
                end
            end
        end
        
        return list
    end
    
local function attackTarget(weaponName, targetCF)
    attackCounter = attackCounter + 1
    
    -- ส่ง Bc (เดิม)
    pcall(function()
        TNet:FireServer(
            'Bu',
            attackCounter,
            workspace:GetServerTimeNow(),
            1,
            tostring(weaponName),
            {
                hitNum = attackCounter % 4,
                onHitAnimName = tostring(weaponName) .. '1',
                hrtCF = targetCF,
            }
        )
    end)


    -- ส่ง Bc (เดิม)
    pcall(function()
        TNet:FireServer(
            'Bd',
            attackCounter,
            workspace:GetServerTimeNow(),
            1,
            tostring(weaponName),
            {
                hitNum = attackCounter % 4,
                onHitAnimName = tostring(weaponName) .. '1',
                hrtCF = targetCF,
            }
        )
    end)

    -- ส่ง Bc (เดิม)
    pcall(function()
        TNet:FireServer(
            'Bg',
            attackCounter,
            workspace:GetServerTimeNow(),
            1,
            tostring(weaponName),
            {
                hitNum = attackCounter % 4,
                onHitAnimName = tostring(weaponName) .. '1',
                hrtCF = targetCF,
            }
        )
    end)
end


    local currentTargetIndex = 1
    local lastEnemyRefresh = 0
    
    -- Separate refresh loop for enemies
    spawn(function()
        while self.Enabled do
            wait(0.5)
            -- This will constantly refresh enemy list every 0.5 seconds
            if self.Enabled then
                self.currentEnemies = getActiveEnemies()
            end
        end
    end)
    
    self.currentEnemies = getActiveEnemies() -- Initial scan

    self.MainLoop = RunService.Heartbeat:Connect(function()
        if not self.Enabled then return end
        
        local me = HRP()
        if not me then return end

        -- Get config values with defaults if nil
        local MAX_TARGETS = tonumber(getgenv().KapaoConfig.KillAura_MaxTargets) or 3
        local LIMIT_RANGE = tonumber(getgenv().KapaoConfig.KillAura_Range) or 1500
        local MODE = getgenv().KapaoConfig.KillAura_Mode or 'both'
        local PREDICTIVE_AIM = getgenv().KapaoConfig.KillAura_PredictiveAim
        local PREDICTION_TIME = tonumber(getgenv().KapaoConfig.KillAura_PredictionTime) or 0.12

        -- Always use fresh enemy list
        local now = tick()
        
        -- Force refresh every 0.5 seconds as backup
        if now - lastEnemyRefresh > 0.5 then
            self.currentEnemies = getActiveEnemies()
            lastEnemyRefresh = now
        end

        local cand = {}
        for _, enemyModel in ipairs(self.currentEnemies or {}) do
            if isAlive(enemyModel) then
                local eHRP = findMobHRP(enemyModel)
                if eHRP then
                    local dist = (me.Position - eHRP.Position).Magnitude
                    if (not LIMIT_RANGE) or (dist <= LIMIT_RANGE) then
                        table.insert(cand, { hrp = eHRP, dist = dist, model = enemyModel })
                    end
                end
            end
        end

        if #cand == 0 then 
            -- Immediately refresh if no enemies found
            self.currentEnemies = getActiveEnemies()
            return 
        end

        local deltaTime = now - lastUpdateTime
        lastUpdateTime = now
        
        -- Update enemy velocity data
        local currentEnemiesInList = {}
        for _, enemyInfo in ipairs(cand) do
            local enemyModel = enemyInfo.model
            currentEnemiesInList[enemyModel] = true
            local eHRP = enemyInfo.hrp
            
            if not enemyData[enemyModel] then
                enemyData[enemyModel] = { lastPos = eHRP.Position, velocity = Vector3.new() }
            else
                if deltaTime > 0.001 then
                    local velocity = (eHRP.Position - enemyData[enemyModel].lastPos) / deltaTime
                    enemyData[enemyModel].velocity = enemyData[enemyModel].velocity:Lerp(velocity, 0.5)
                end
                enemyData[enemyModel].lastPos = eHRP.Position
            end
        end

        -- Clean up old enemy data
        for enemyModelInCache, _ in pairs(enemyData) do
            if not currentEnemiesInList[enemyModelInCache] then
                enemyData[enemyModelInCache] = nil
            end
        end

        -- Sort by distance
        table.sort(cand, function(a, b) return a.dist < b.dist end)
        
        -- Select targets (with nil check)
        local targetsToHit = {}
        local maxTargetsToHit = MAX_TARGETS or 3 -- Default to 3 if nil
        for i = 1, math.min(#cand, maxTargetsToHit) do
            table.insert(targetsToHit, {hrp = cand[i].hrp, model = cand[i].model})
        end
        
        if #targetsToHit == 0 then return end
        
        -- Cycle through targets
        if currentTargetIndex > #targetsToHit then
            currentTargetIndex = 1
        end

        local targetInfo = targetsToHit[currentTargetIndex]
        if targetInfo and isAlive(targetInfo.model) then
            local targetHRP = targetInfo.hrp
            local targetModel = targetInfo.model
            
            local targetCF = targetHRP.CFrame
            
            -- Predictive aiming
            if PREDICTIVE_AIM and enemyData[targetModel] then
                local velocity = enemyData[targetModel].velocity
                if velocity.Magnitude > 1 then
                    local predictedPos = targetHRP.Position + (velocity * PREDICTION_TIME)
                    targetCF = CFrame.new(predictedPos) * (targetHRP.CFrame - targetHRP.Position)
                end
            end

            -- Weapon selection
            local weaponToUse = DEFAULT_WEAPON_AUTO
            if MODE == 'auto' then
                local detectedWeapon = LP.Character and LP.Character:FindFirstChildWhichIsA('Tool')
                if detectedWeapon then weaponToUse = detectedWeapon.Name end
            elseif MODE:match('^force:(.+)$') then
                weaponToUse = MODE:match('^force:(.+)$')
            end

            -- Attack execution
            if MODE == 'both' then
                for weaponName, _ in pairs(ATTACK_PROFILES) do
                    attackTarget(weaponName, targetCF)
                end
            else
                attackTarget(weaponToUse, targetCF)
            end
            
            currentTargetIndex = currentTargetIndex + 1
        else
            currentTargetIndex = 1
        end
    end)
    
    -- Monitor for room changes
    if LP.Character then
        self.RoomChangeConnection = LP.Character:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
            -- Force immediate refresh on room change
            self.currentEnemies = getActiveEnemies()
            enemyData = {} -- Clear velocity data
        end)
    end
end

function KillAuraSystem:Stop()
    self.Enabled = false
    if self.MainLoop and self.MainLoop.Connected then
        self.MainLoop:Disconnect()
        self.MainLoop = nil
    end
    if self.RoomChangeConnection then
        self.RoomChangeConnection:Disconnect()
        self.RoomChangeConnection = nil
    end
end

-- Auto Farm Dungeon System (integrated)
local AutoFarmSystem = {}
AutoFarmSystem.Enabled = false
AutoFarmSystem.bossDetected = false
AutoFarmSystem.touchedDoors = {}
AutoFarmSystem.openedChests = {}
AutoFarmSystem.lastClearTime = 0
AutoFarmSystem.antiSitConns = {}
AutoFarmSystem.noclipConn = nil

local function onScreen(gui, playerGui)
    if not (gui and playerGui and gui:IsDescendantOf(playerGui)) then
        return false
    end
    local a = gui
    while a and not a:IsA('ScreenGui') do
        if a:IsA('GuiObject') and not a.Visible then
            return false
        end
        local cg = a:FindFirstChildOfClass('CanvasGroup')
        if cg and cg.GroupTransparency and cg.GroupTransparency >= 1 then
            return false
        end
        a = a.Parent
    end
    return a ~= nil and a.Enabled
end

do
    local RS_local = ReplicatedFirst
    local seen = setmetatable({}, { __mode = 'k' })
    local WIN_KEYS = { 'winner', 'victory', 'dungeon clear', 'stage clear' }
    local BOSS_KEYS = { 'boss', 'final boss', 'dungeon boss', 'raid boss', 'mini boss', 'elite boss' }

    local function hasTextInList(s, list)
        s = (s or ''):lower()
        for _, k in ipairs(list) do
            if s:find(k, 1, true) then return true end
        end
        return false
    end

    local function setBaseline(inst, playerGui)
        local vis = inst:IsA('GuiObject') and inst.Visible or false
        seen[inst] = vis and onScreen(inst, playerGui)
    end

    local function risingEdge(inst, playerGui)
        local nowVis = (inst:IsA('GuiObject') and inst.Visible or false) and onScreen(inst, playerGui)
        local prev = seen[inst]
        seen[inst] = nowVis
        return (not prev) and nowVis
    end

    function AutoFarmSystem:updateCharacterRefs()
        self.Character = LP.Character
        self.Humanoid = self.Character and self.Character:FindFirstChild('Humanoid')
    end

    function AutoFarmSystem:startAntiSit()
        if not getgenv().KapaoConfig.AutoFarm_AntiSit then return end
        self:updateCharacterRefs()
        if not self.Character or not self.Humanoid then return end
        pcall(function()
            self.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        end)
        for k, c in pairs(self.antiSitConns) do
            pcall(function() c:Disconnect() end)
            self.antiSitConns[k] = nil
        end
        self.antiSitConns.sit = self.Humanoid:GetPropertyChangedSignal('Sit'):Connect(function()
            if self.Humanoid.Sit then
                self.Humanoid.Sit = false
                task.defer(function()
                    local weld = self.Character:FindFirstChild('SeatWeld', true)
                    if weld then weld:Destroy() end
                end)
            end
        end)
        self.antiSitConns.seatpart = self.Humanoid:GetPropertyChangedSignal('SeatPart'):Connect(function()
            if self.Humanoid.SeatPart then
                self.Humanoid.Sit = false
                task.defer(function()
                    local weld = self.Character:FindFirstChild('SeatWeld', true)
                    if weld then weld:Destroy() end
                end)
            end
        end)
        self.antiSitConns.childadded = self.Character.ChildAdded:Connect(function(ch)
            if ch.Name == 'SeatWeld' then ch:Destroy() end
        end)
    end

    function AutoFarmSystem:stopAntiSit()
        for k, c in pairs(self.antiSitConns) do
            pcall(function() c:Disconnect() end)
            self.antiSitConns[k] = nil
        end
    end

    function AutoFarmSystem:getCharacter()
        return LP.Character
    end

    function AutoFarmSystem:getHRP()
        local char = self:getCharacter()
        return char and char:FindFirstChild('HumanoidRootPart')
    end

    function AutoFarmSystem:setNoclip(on)
        if not getgenv().KapaoConfig.AutoFarm_Noclip then return end
        self:updateCharacterRefs()
        if on then
            if self.noclipConn then return end
            self.noclipConn = RunService.Stepped:Connect(function()
                if self.Character then
                    for _, p in ipairs(self.Character:GetDescendants()) do
                        if p:IsA('BasePart') and p.CanCollide then
                            p.CanCollide = false
                        end
                    end
                    if self.Humanoid and self.Humanoid.Sit then
                        self.Humanoid.Sit = false
                    end
                    local sw = self.Character:FindFirstChild('SeatWeld', true)
                    if sw then sw:Destroy() end
                end
            end)
        else
            if self.noclipConn then
                self.noclipConn:Disconnect()
                self.noclipConn = nil
            end
        end
    end

    function AutoFarmSystem:startHover()
        if not getgenv().KapaoConfig.AutoFarm_Hover then return end
        if self.hoverConn then return end
        
        self.hoverConn = RunService.Heartbeat:Connect(function()
            local hrp = self:getHRP()
            if not hrp then return end
            
            -- หาศัตรูที่ใกล้ที่สุดและยังมีชีวิต
            local nearestEnemy = nil
            local shortestDistance = math.huge
            
            -- ตรวจสอบศัตรูจาก CollectionService
            for _, enemy in ipairs(CollectionService:GetTagged('Enemy')) do
                if enemy and enemy.Parent then
                    local humanoid = enemy:FindFirstChildOfClass('Humanoid')
                    local enemyHRP = enemy:FindFirstChild('HumanoidRootPart')
                    -- ตรวจสอบว่ามอนยังมีชีวิตและไม่ได้ตาย
                    if humanoid and enemyHRP and humanoid.Health > 0 and not enemy:GetAttribute('Died') then
                        local distance = (hrp.Position - enemyHRP.Position).Magnitude
                        if distance < shortestDistance and distance < 50 then -- เพิ่มระยะเป็น 50 studs
                            shortestDistance = distance
                            nearestEnemy = enemy
                        end
                    end
                end
            end
            
            -- ตรวจสอบศัตรูจาก workspace (เพิ่มการตรวจสอบเพิ่มเติม)
            for _, obj in ipairs(workspace:GetChildren()) do
                if obj:IsA('Model') and obj ~= LP.Character then
                    local humanoid = obj:FindFirstChildOfClass('Humanoid')
                    local enemyHRP = obj:FindFirstChild('HumanoidRootPart')
                    -- ตรวจสอบว่ามอนยังมีชีวิต ไม่ตาย และไม่ใช่ผู้เล่น
                    if humanoid and enemyHRP and humanoid.Health > 0 and not obj:GetAttribute('Died') and not obj:FindFirstChild('Player') then
                        local distance = (hrp.Position - enemyHRP.Position).Magnitude
                        if distance < shortestDistance and distance < 50 then -- เพิ่มระยะเป็น 50 studs
                            shortestDistance = distance
                            nearestEnemy = obj
                        end
                    end
                end
            end
            
            -- ลอยเหนือศัตรูที่ใกล้ที่สุด (ถ้ามี)
            if nearestEnemy then
                local enemyHRP = nearestEnemy:FindFirstChild('HumanoidRootPart')
                local humanoid = nearestEnemy:FindFirstChildOfClass('Humanoid')
                -- ตรวจสอบอีกครั้งก่อนลอย
                if enemyHRP and humanoid and humanoid.Health > 0 then
                    local hoverHeight = getgenv().KapaoConfig.AutoFarm_HoverHeight or 15
                    local targetPosition = enemyHRP.Position + Vector3.new(0, hoverHeight, 0)
                    -- ล็อค Y ไว้ ไม่หันหน้าลง (ใช้ LookVector เดิมของผู้เล่น)
                    local currentCFrame = hrp.CFrame
                    hrp.CFrame = CFrame.new(targetPosition, targetPosition + currentCFrame.LookVector)
                end
            end
        end)
    end

    function AutoFarmSystem:stopHover()
        if self.hoverConn then
            self.hoverConn:Disconnect()
            self.hoverConn = nil
        end
    end

    function AutoFarmSystem:tweenToPosition(x, y, z, duration)
        local hrp = self:getHRP()
        if not hrp then return false end
        duration = duration or getgenv().KapaoConfig.AutoFarm_TweenSpeed
        local targetCFrame = CFrame.new(x, y, z)
        local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tween = TweenService:Create(hrp, tweenInfo, { CFrame = targetCFrame })
        tween:Play()
        tween.Completed:Wait()
        return true
    end

    function AutoFarmSystem:teleportTo(x, y, z)
        local hrp = self:getHRP()
        if hrp then
            hrp.CFrame = CFrame.new(x, y, z)
            RunService.Heartbeat:Wait()
        end
    end

    function AutoFarmSystem:fireTouch(part)
        local hrp = self:getHRP()
        if not hrp or not part then return end
        local ffi = rawget(getfenv() or {}, 'firetouchinterest') or _G.firetouchinterest
        if ffi then
            pcall(function()
                ffi(hrp, part, 0)
                ffi(hrp, part, 1)
            end)
        end
    end

    function AutoFarmSystem:isRoomCleared()
        local success1, result1 = pcall(function()
            local label = LP.PlayerGui.Main.Float.EnemyNum.TextLabel
            if label and label.Text then
                local text = tostring(label.Text)
                if string.find(text, '0/') then
                    return true
                end
            end
            return false
        end)
        if success1 and result1 then return true end

        local success2, result2 = pcall(function()
            local char = self:getCharacter()
            if not char then return false end
            local roomUUID = char:GetAttribute('CurrentRoom')
            if not roomUUID then return true end
            for _, room in ipairs(workspace:GetChildren()) do
                if room:IsA('Model') and room:GetAttribute('UUID') == roomUUID then
                    local remain = room:GetAttribute('RemainEnemy')
                    if remain and tonumber(remain) == 0 then
                        return true
                    end
                end
            end
            return false
        end)
        return success2 and result2
    end

    function AutoFarmSystem:findDungeonChests()
        local chests = {}
        local success = pcall(function()
            for _, chest in ipairs(CollectionService:GetTagged('DungeonChest')) do
                if chest:IsA('Model') and not self.openedChests[chest] then
                    local prompt = chest:FindFirstChild('ProximityPrompt', true)
                    if prompt and prompt.Enabled then
                        table.insert(chests, {
                            model = chest,
                            prompt = prompt,
                            identity = chest:GetAttribute('Identity'),
                            position = {
                                x = chest.PrimaryPart and chest.PrimaryPart.Position.X or 0,
                                y = chest.PrimaryPart and chest.PrimaryPart.Position.Y or 0,
                                z = chest.PrimaryPart and chest.PrimaryPart.Position.Z or 0,
                            },
                        })
                    end
                end
            end
            if #chests == 0 then
                for _, obj in ipairs(workspace:GetDescendants()) do
                    if obj:IsA('Model') and (string.find(obj.Name:lower(), 'chest') or string.find(obj.Name:lower(), 'dungeonchest')) and not self.openedChests[obj] then
                        local prompt = obj:FindFirstChild('ProximityPrompt', true)
                        if prompt and prompt.Enabled then
                            table.insert(chests, {
                                model = obj,
                                prompt = prompt,
                                identity = obj:GetAttribute('Identity'),
                                position = {
                                    x = obj.PrimaryPart and obj.PrimaryPart.Position.X or 0,
                                    y = obj.PrimaryPart and obj.PrimaryPart.Position.Y or 0,
                                    z = obj.PrimaryPart and obj.PrimaryPart.Position.Z or 0,
                                },
                            })
                        end
                    end
                end
            end
        end)
        return success and chests or {}
    end

    function AutoFarmSystem:isInSameRoom(pos1, pos2)
        local dx = pos1.x - pos2.x
        local dy = pos1.y - pos2.y
        local dz = pos1.z - pos2.z
        local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
        return distance <= 500
    end

    function AutoFarmSystem:findChestsInMyRoom()
        local hrp = self:getHRP()
        if not hrp then return {} end
        local myPos = { x = hrp.Position.X, y = hrp.Position.Y, z = hrp.Position.Z }
        local chests = self:findDungeonChests()
        local chestsInRoom = {}
        for _, chest in ipairs(chests) do
            if self:isInSameRoom(myPos, chest.position) then
                local dx = chest.position.x - myPos.x
                local dy = chest.position.y - myPos.y
                local dz = chest.position.z - myPos.z
                chest.distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                table.insert(chestsInRoom, chest)
            end
        end
        table.sort(chestsInRoom, function(a, b) return a.distance < b.distance end)
        return chestsInRoom
    end

    function AutoFarmSystem:waitForChestToBeReady(chest)
        local maxWaitTime = 3
        local startTime = tick()
        while tick() - startTime < maxWaitTime do
            if chest.prompt and chest.prompt.Enabled and chest.prompt.Parent then
                local hrp = self:getHRP()
                if hrp then
                    local distance = (hrp.Position - Vector3.new(chest.position.x, chest.position.y, chest.position.z)).Magnitude
                    if distance <= (chest.prompt.MaxActivationDistance or 10) then
                        return true
                    end
                end
            end
            task.wait(0.1)
        end
        return false
    end

    function AutoFarmSystem:openChest(chest)
        if not chest or not chest.prompt then return false end
        local chestPos = chest.position
        self:setNoclip(true)
        self:teleportTo(chestPos.x, chestPos.y + 2, chestPos.z)
        task.wait(0.5)
        if not self:waitForChestToBeReady(chest) then
            self:setNoclip(false)
            return false
        end
        if not chest.prompt or not chest.prompt.Enabled then
            self:setNoclip(false)
            return false
        end
        local success = pcall(function()
            if fireproximityprompt then
                fireproximityprompt(chest.prompt)
            else
                chest.prompt:InputHoldBegin()
                local holdTime = math.max(chest.prompt.HoldDuration or 0, 0.5)
                task.wait(holdTime + 0.2)
                chest.prompt:InputHoldEnd()
            end
        end)
        if success then
            self.openedChests[chest.model] = true
            task.wait(2)
            self:setNoclip(false)
            return true
        else
            self:setNoclip(false)
            return false
        end
    end

    function AutoFarmSystem:findDoorTouchInterests()
        local doors = {}
        local success = pcall(function()
            for _, room in ipairs(workspace:GetChildren()) do
                if room:IsA('Model') or room:IsA('Folder') then
                    for _, obj in ipairs(room:GetChildren()) do
                        if obj.Name == 'Door' and (obj:IsA('Model') or obj:IsA('Folder')) then
                            local collider = obj:FindFirstChild('Collider')
                            if collider and collider:IsA('BasePart') then
                                local touchInterest = collider:FindFirstChild('TouchInterest')
                                if touchInterest and touchInterest:IsA('TouchTransmitter') then
                                    local backCF = room:FindFirstChild('BackCF')
                                    local nextCF = room:FindFirstChild('NextCF')
                                    if backCF and nextCF and backCF:IsA('BasePart') and nextCF:IsA('BasePart') then
                                        table.insert(doors, {
                                            room = room,
                                            door = obj,
                                            collider = collider,
                                            touchInterest = touchInterest,
                                            backCF = backCF,
                                            nextCF = nextCF,
                                            colliderPos = { x = collider.Position.X, y = collider.Position.Y, z = collider.Position.Z },
                                            backPos = { x = backCF.Position.X, y = backCF.Position.Y, z = backCF.Position.Z },
                                            nextPos = { x = nextCF.Position.X, y = nextCF.Position.Y, z = nextCF.Position.Z },
                                        })
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        return success and doors or {}
    end

    function AutoFarmSystem:findBestForwardDoor()
        local hrp = self:getHRP()
        if not hrp then return nil end
        local myX, myY, myZ = hrp.Position.X, hrp.Position.Y, hrp.Position.Z
        local doors = self:findDoorTouchInterests()
        local best = nil
        local bestScore = -999999
        for _, door in ipairs(doors) do
            if not self.touchedDoors[door.touchInterest] then
                local dx1 = door.colliderPos.x - myX
                local dy1 = door.colliderPos.y - myY
                local dz1 = door.colliderPos.z - myZ
                local distToCollider = math.sqrt(dx1 * dx1 + dy1 * dy1 + dz1 * dz1)
                local dx_back = door.colliderPos.x - door.backPos.x
                local dy_back = door.colliderPos.y - door.backPos.y
                local dz_back = door.colliderPos.z - door.backPos.z
                local distToBack = math.sqrt(dx_back * dx_back + dy_back * dy_back + dz_back * dz_back)
                local dx_next = door.colliderPos.x - door.nextPos.x
                local dy_next = door.colliderPos.y - door.nextPos.y
                local dz_next = door.colliderPos.z - door.nextPos.z
                local distToNext = math.sqrt(dx_next * dx_next + dy_next * dy_next + dz_next * dz_next)
                local isForwardDoor = distToBack < distToNext
                local distPlayerToBack = math.sqrt((myX - door.backPos.x) ^ 2 + (myZ - door.backPos.z) ^ 2)
                local distPlayerToNext = math.sqrt((myX - door.nextPos.x) ^ 2 + (myZ - door.nextPos.z) ^ 2)
                if distPlayerToNext < distPlayerToBack and distToBack < distToNext then
                    isForwardDoor = true
                end
                if isForwardDoor and distToCollider < 2000 then
                    local score = 10000
                    if distToBack < 100 then score = score + 2000 end
                    score = score - distToCollider * 0.3
                    local totalDist = math.sqrt((door.nextPos.x - door.backPos.x) ^ 2 + (door.nextPos.y - door.backPos.y) ^ 2 + (door.nextPos.z - door.backPos.z) ^ 2)
                    local ratio = distToBack / totalDist
                    if ratio >= 0 and ratio < 0.4 then score = score + 1000 end
                    if score > bestScore then
                        best = door
                        bestScore = score
                    end
                end
            end
        end
        return best, bestScore
    end

    function AutoFarmSystem:touchDoor(door)
        if not door then return false end
        local colliderPos = door.colliderPos
        local backPos = door.backPos
        local hrp = self:getHRP()
        if not hrp then return false end
        local originalPos = hrp.Position
        self:setNoclip(true)
        local success1 = self:tweenToPosition(colliderPos.x, colliderPos.y + 3, colliderPos.z, getgenv().KapaoConfig.AutoFarm_TweenSpeed)
        if not success1 then
            self:setNoclip(false)
            return false
        end
        for i = 1, 10 do
            self:fireTouch(door.collider)
            task.wait(0.01)
            local currentPos = self:getHRP().Position
            local distanceMoved = (currentPos - originalPos).Magnitude
            if distanceMoved > 100 then
                self:setNoclip(false)
                self.touchedDoors[door.touchInterest] = true
                return true
            end
        end
        local dirX = backPos.x - colliderPos.x
        local dirZ = backPos.z - colliderPos.z
        local len = math.sqrt(dirX * dirX + dirZ * dirZ)
        if len > 0 then
            dirX = dirX / len
            dirZ = dirZ / len
            local targetX = colliderPos.x + dirX * 8
            local targetY = colliderPos.y + 3
            local targetZ = colliderPos.z + dirZ * 8
            self:tweenToPosition(targetX, targetY, targetZ, 0.2)
        end
        self:setNoclip(false)
        self.touchedDoors[door.touchInterest] = true
        return true
    end

    function AutoFarmSystem:mainLoop()
        while self.Enabled do
            pcall(function()
                if self.bossDetected then
                    task.wait(5)
                    return
                end
                local PG = LP:FindFirstChild('PlayerGui')
                if PG then
                    -- quick check for boss text each loop
                    pcall(function()
                        for _, gui in ipairs(PG:GetDescendants()) do
                            if (gui:IsA('TextLabel') or gui:IsA('TextButton')) and gui.Visible and onScreen(gui, PG) and gui.Text then
                                if hasTextInList(gui.Text, BOSS_KEYS) then
                                    self.bossDetected = true
                                    break
                                end
                            end
                        end
                    end)
                end
                if self.bossDetected then
                    task.wait(5)
                    return
                end
                local roomCleared = self:isRoomCleared()
                if not roomCleared then
                    self.lastClearTime = 0
                    task.wait(3)
                    return
                end
                if self.lastClearTime == 0 then
                    self.lastClearTime = tick()
                end
                local waitTime = tick() - self.lastClearTime
                if waitTime < getgenv().KapaoConfig.AutoFarm_RoomClearDelay then
                    task.wait(0.3)
                    return
                end
                local chestsInRoom = self:findChestsInMyRoom()
                if getgenv().KapaoConfig.AutoFarm_AutoChest and #chestsInRoom > 0 then
                    for i, chest in ipairs(chestsInRoom) do
                        self:openChest(chest)
                        if i < #chestsInRoom then
                            task.wait(getgenv().KapaoConfig.AutoFarm_ChestDelay)
                        end
                    end
                    task.wait(1.0)
                    local remainingChests = self:findChestsInMyRoom()
                    if #remainingChests > 0 then
                        task.wait(1.0)
                        return
                    end
                end
                local bestDoor = self:findBestForwardDoor()
                if bestDoor then
                    local success = self:touchDoor(bestDoor)
                    if success then
                        self.lastClearTime = 0
                        task.wait(5)
                    else
                        task.wait(2)
                    end
                else
                    task.wait(5)
                end
            end)
            task.wait(2)
        end
    end

    function AutoFarmSystem:Start()
        if self.Enabled then return end
        if not isAutoHealAllowed() then
            return
        end
        -- Boot gate: ensure essentials exist
        waitFor(function()
            return ReplicatedStorage:FindFirstChild('TNetSent') ~= nil or not ReplicatedFirst:FindFirstChild('Component')
        end, 30)
        local Char = LP.Character or LP.CharacterAdded:Wait()
        Char:WaitForChild('HumanoidRootPart', 30)
        Char:WaitForChild('Humanoid', 30)
        local PG = waitFor(function() return LP:FindFirstChild('PlayerGui') end, 15)
        if PG then
            waitFor(function() return PG:FindFirstChild('Main') end, 30)
        end
        if workspace.StreamingEnabled then task.wait(1.0) end
        if not ReplicatedStorage:FindFirstChild('TNetSent') then
                return
        end
        -- Event-based Auto Retry: listen for official dungeon end event and fire retry
        local RETRY_REMOTE_NAME = 'Dungeon_RetryCmd'
        local DUNGEON_END_EVENT_NAME = 'Dungeon_LeavedWait'
        local okRequire, TNetModule = pcall(function()
            return require(ReplicatedFirst.Component.TNet)
        end)
        if okRequire and TNetModule and TNetModule.SetEvent and TNetModule.FireServer then
            pcall(function()
                if getgenv().KapaoConfig.AutoFarm_AutoRetry then
                    TNetModule.SetEvent(DUNGEON_END_EVENT_NAME, function()
                        task.wait(1.5)
                        TNetModule.FireServer(RETRY_REMOTE_NAME)
                    end)
                else
                    TNetModule.SetEvent(DUNGEON_END_EVENT_NAME, nil)
                end
            end)
            self._tNet = TNetModule
            self._retryEventName = DUNGEON_END_EVENT_NAME
        end
        self.Enabled = true
        self:updateCharacterRefs()
        self:startAntiSit()
        self:startHover()
        self.MainLoop = task.spawn(function()
            self:mainLoop()
        end)
    end

    function AutoFarmSystem:Stop()
        self.Enabled = false
        self:stopAntiSit()
        self:stopHover()
        self:setNoclip(false)
        if self.MainLoop then
            task.cancel(self.MainLoop)
            self.MainLoop = nil
        end
        if self._tNet and self._retryEventName then
            pcall(function()
                self._tNet.SetEvent(self._retryEventName, nil)
            end)
            self._tNet = nil
            self._retryEventName = nil
        end
    end

    function AutoFarmSystem:Reset()
        self.touchedDoors = {}
        self.openedChests = {}
        self.lastClearTime = 0
        self.bossDetected = false
    end
end

-- Combat Tab UI Elements (same as before)
do
    -- Header with Logo mention
    Tabs.Combat:AddParagraph({
        Title = "🎮 Kapao Hub Combat Settings",
        Content = "Kill Aura with predictive aim"
    })

    -- Main Kill Aura Section
    local CombatSection = Tabs.Combat:AddSection("Kill Aura Settings")

    -- Kill Aura Toggle
    local KillAuraToggle = Tabs.Combat:AddToggle("KillAuraEnabled", {
        Title = "⚔️ Kill Aura",
        Description = "Auto-target enemies",
        Default = false
    })

    KillAuraToggle:OnChanged(function()
        getgenv().KapaoConfig.KillAura_Enabled = Options.KillAuraEnabled.Value
        if Options.KillAuraEnabled.Value then
            KillAuraSystem:Start()
        else
            KillAuraSystem:Stop()
        end
    end)

    -- Range Slider
    local RangeSlider = Tabs.Combat:AddSlider("KillAuraRange", {
        Title = "📏 Attack Range",
        Description = "Max range",
        Default = 1500,
        Min = 100,
        Max = 5000,
        Rounding = 0,
        Callback = function(Value)
            getgenv().KapaoConfig.KillAura_Range = Value
        end
    })

    -- Max Targets Slider
    local MaxTargetsSlider = Tabs.Combat:AddSlider("MaxTargets", {
        Title = "🎯 Max Targets",
        Description = "Targets",
        Default = 3,
        Min = 1,
        Max = 10,
        Rounding = 0,
        Callback = function(Value)
            getgenv().KapaoConfig.KillAura_MaxTargets = Value
        end
    })

    -- Attack Mode Dropdown
    local AttackModeDropdown = Tabs.Combat:AddDropdown("AttackMode", {
        Title = "⚔️ Attack Mode",
        Description = "Weapon mode",
        Values = {"both", "auto", "force:DuoSword", "force:SwordShield", "force:Wood"},
        Multi = false,
        Default = 1,
    })

    AttackModeDropdown:OnChanged(function(Value)
        getgenv().KapaoConfig.KillAura_Mode = Value
    end)

    -- Advanced Settings Section
    local AdvancedSection = Tabs.Combat:AddSection("Advanced Settings")

    -- Predictive Aim Toggle
    local PredictiveToggle = Tabs.Combat:AddToggle("PredictiveAim", {
        Title = "🎯 Predictive Aim",
        Description = "Predict aim",
        Default = true
    })

    PredictiveToggle:OnChanged(function()
        getgenv().KapaoConfig.KillAura_PredictiveAim = Options.PredictiveAim.Value
    end)

    -- Prediction Time Slider
    local PredictionSlider = Tabs.Combat:AddSlider("PredictionTime", {
        Title = "⏱️ Prediction Time",
        Description = "Prediction (s)",
        Default = 0.12,
        Min = 0.06,
        Max = 0.30,
        Rounding = 2,
        Callback = function(Value)
            getgenv().KapaoConfig.KillAura_PredictionTime = Value
        end
    })
end

-- Auto Farm Tab UI
do
    Tabs.AutoFarm:AddParagraph({
        Title = "🗺️ Auto Farm Settings",
        Content = "Auto clear dungeon with chest looting and door progression"
    })

    local Main = Tabs.AutoFarm:AddSection("Main")

    local AutoFarmToggle = Tabs.AutoFarm:AddToggle("AutoFarmEnabled", {
        Title = "🛠️ Enable Auto Farm",
        Description = "Auto-clear rooms",
        Default = false
    })

    AutoFarmToggle:OnChanged(function()
        getgenv().KapaoConfig.AutoFarm_Enabled = Options.AutoFarmEnabled.Value
        if Options.AutoFarmEnabled.Value then
            AutoFarmSystem:Start()
        else
            AutoFarmSystem:Stop()
        end
    end)

    local Behavior = Tabs.AutoFarm:AddSection("Behavior")

    local AntiSitToggle = Tabs.AutoFarm:AddToggle("AutoFarmAntiSit", {
        Title = "🙅 Anti-Sit",
        Description = "Block seat",
        Default = true
    })
    AntiSitToggle:OnChanged(function()
        getgenv().KapaoConfig.AutoFarm_AntiSit = Options.AutoFarmAntiSit.Value
        if AutoFarmSystem.Enabled and not Options.AutoFarmAntiSit.Value then
            AutoFarmSystem:stopAntiSit()
        elseif AutoFarmSystem.Enabled and Options.AutoFarmAntiSit.Value then
            AutoFarmSystem:startAntiSit()
        end
    end)

    local NoclipToggle = Tabs.AutoFarm:AddToggle("AutoFarmNoclip", {
        Title = "🧱 Noclip While Moving",
        Description = "No collide",
        Default = true
    })
    NoclipToggle:OnChanged(function()
        getgenv().KapaoConfig.AutoFarm_Noclip = Options.AutoFarmNoclip.Value
        if AutoFarmSystem.Enabled and not Options.AutoFarmNoclip.Value then
            AutoFarmSystem:setNoclip(false)
        end
    end)

    local AutoChestToggle = Tabs.AutoFarm:AddToggle("AutoFarmAutoChest", {
        Title = "🗝️ Auto Chest",
        Description = "Auto open",
        Default = true
    })
    AutoChestToggle:OnChanged(function()
        getgenv().KapaoConfig.AutoFarm_AutoChest = Options.AutoFarmAutoChest.Value
    end)

    local HoverToggle = Tabs.AutoFarm:AddToggle("AutoFarmHover", {
        Title = "🕊️ Hover Above Enemies",
        Description = "Float above monsters",
        Default = false
    })
    HoverToggle:OnChanged(function()
        getgenv().KapaoConfig.AutoFarm_Hover = Options.AutoFarmHover.Value
        if AutoFarmSystem.Enabled and Options.AutoFarmHover.Value then
            AutoFarmSystem:startHover()
        elseif AutoFarmSystem.Enabled and not Options.AutoFarmHover.Value then
            AutoFarmSystem:stopHover()
        end
    end)

    local HoverHeightSlider = Tabs.AutoFarm:AddSlider("AutoFarmHoverHeight", {
        Title = "📏 Hover Height",
        Description = "Height above enemies",
        Default = 15,
        Min = 5,
        Max = 50,
        Rounding = 0,
        Callback = function(Value)
            getgenv().KapaoConfig.AutoFarm_HoverHeight = Value
        end
    })

    local Timing = Tabs.AutoFarm:AddSection("Timing")

    local ChestDelay = Tabs.AutoFarm:AddSlider("AutoFarmChestDelay", {
        Title = "⏱️ Chest Delay (s)",
        Description = "Delay",
        Default = 0.4,
        Min = 0.1,
        Max = 2,
        Rounding = 2,
        Callback = function(Value)
            getgenv().KapaoConfig.AutoFarm_ChestDelay = Value
        end
    })

    local RoomClearDelay = Tabs.AutoFarm:AddSlider("AutoFarmRoomClearDelay", {
        Title = "⌛ Room Clear Wait (s)",
        Description = "Post-clear wait",
        Default = 0.4,
        Min = 0.1,
        Max = 3,
        Rounding = 2,
        Callback = function(Value)
            getgenv().KapaoConfig.AutoFarm_RoomClearDelay = Value
        end
    })

    local TweenSpeed = Tabs.AutoFarm:AddSlider("AutoFarmTweenSpeed", {
        Title = "🏃 Move Tween Time (s)",
        Description = "Move time",
        Default = 0.3,
        Min = 0.1,
        Max = 2,
        Rounding = 2,
        Callback = function(Value)
            getgenv().KapaoConfig.AutoFarm_TweenSpeed = Value
        end
    })

    local Utils = Tabs.AutoFarm:AddSection("Utilities")
    Tabs.AutoFarm:AddButton({
        Title = "🔄 Reset Auto Farm Cache",
        Description = "Clear touched doors and opened chests",
        Callback = function()
            AutoFarmSystem:Reset()
        end
    })

end

-- Misc Tab UI
do
    local AutoRetryToggle = Tabs.Misc:AddToggle("AutoFarmAutoRetry", {
        Title = "🔁 Auto Retry",
        Description = "Auto restart",
        Default = true
    })
    AutoRetryToggle:OnChanged(function()
        if not isAutoHealAllowed() then
            getgenv().KapaoConfig.AutoFarm_AutoRetry = false
            return
        end
        
        getgenv().KapaoConfig.AutoFarm_AutoRetry = Options.AutoFarmAutoRetry.Value
        -- Apply immediately if system running
        if AutoFarmSystem and AutoFarmSystem._tNet and AutoFarmSystem._retryEventName then
            pcall(function()
                AutoFarmSystem._tNet.SetEvent(AutoFarmSystem._retryEventName, nil)
            end)
            if Options.AutoFarmAutoRetry.Value then
                pcall(function()
                    AutoFarmSystem._tNet.SetEvent(AutoFarmSystem._retryEventName, function()
                        task.wait(1.5)
                        AutoFarmSystem._tNet.FireServer('Dungeon_RetryCmd')
                    end)
                end)
            end
        end
    end)

    local AutoHealToggle = Tabs.Misc:AddToggle("AutoHealEnabled", {
        Title = "💊 Inf Auto Heal",
        Description = "Add & use potions",
        Default = false
    })

    -- Lightweight Auto Heal system
    local AutoHealSystem = { Enabled = false, addJob = nil, useJob = nil }

    function AutoHealSystem:Start()
        if self.Enabled then return end
        if not isAutoHealAllowed() then
            return
        end
        self.Enabled = true
        getgenv().KapaoConfig.AutoHeal_Enabled = true
        local rs = game:GetService('ReplicatedStorage')
        local tnet = waitFor(function()
            return rs:FindFirstChild('TNetSent')
        end, 15)
        if not tnet then
            self.Enabled = false
            getgenv().KapaoConfig.AutoHeal_Enabled = false
            return
        end
        self.addJob = task.spawn(function()
            while self.Enabled do
                pcall(function()
                    tnet:FireServer('y', 28, { { id = 1110001, num = 2 } })
                end)
                task.wait(0.5)
            end
        end)
        self.useJob = task.spawn(function()
            while self.Enabled do
                pcall(function()
                    tnet:FireServer('0', 17)  -- Changed back to 'o' for AutoHeal
                end)
                task.wait(0.5)
            end
        end)
    end

    function AutoHealSystem:Stop()
        self.Enabled = false
        getgenv().KapaoConfig.AutoHeal_Enabled = false
        if self.addJob then pcall(function() task.cancel(self.addJob) end) self.addJob = nil end
        if self.useJob then pcall(function() task.cancel(self.useJob) end) self.useJob = nil end
    end



    -- Dupe Weapons System (Updated Version)
    local DupeWeaponsToggle = Tabs.Misc:AddToggle("DupeWeaponsEnabled", {
        Title = "⚔️ Dupe Weapons",
        Description = "Duplicate weapons infinitely",
        Default = false
    })

    local DupeWeaponsSystem = { 
        Enabled = false, 
        addPotionLoop = nil, 
        usePotionLoop1 = nil,
        usePotionLoop2 = nil,
        usePotionLoop3 = nil
    }

    -- Updated Dupe Functions
    local function addPotion(TNetSent, isDuping)
        if not isDuping then return end
        TNetSent:FireServer("y", 28, { { id = 1150005, num = 2 } })
    end

    local function usePotion0(TNetSent, isDuping)
        if not isDuping then return end
        TNetSent:FireServer("0", 17)
    end

    local function usePotionP(TNetSent, isDuping)
        if not isDuping then return end
        TNetSent:FireServer("p", 17)
    end

    local function usePotionO(TNetSent, isDuping)
        if not isDuping then return end
        TNetSent:FireServer("o", 17)
    end

        local function usePotionO(TNetSent, isDuping)
        if not isDuping then return end
        TNetSent:FireServer("z", 17)
    end

    function DupeWeaponsSystem:Start()
        if self.Enabled then return end
        -- Dupe weapons works everywhere, no placeid restriction
        self.Enabled = true
        getgenv().KapaoConfig.DupeWeapons_Enabled = true

        local rs = game:GetService('ReplicatedStorage')
        local tnet = waitFor(function()
            return rs:FindFirstChild('TNetSent')
        end, 15)
        if not tnet then
            self.Enabled = false
            getgenv().KapaoConfig.DupeWeapons_Enabled = false
            return
        end

        -- Add potion loop (every 1 second)
        self.addPotionLoop = task.spawn(function()
            while self.Enabled do
                pcall(function()
                    addPotion(tnet, self.Enabled)
                end)
                task.wait(1)
            end
        end)

        -- Use potion "0" loop (every 0.3 seconds)
        self.usePotionLoop1 = task.spawn(function()
            while self.Enabled do
                pcall(function()
                    usePotion0(tnet, self.Enabled)
                end)
                task.wait(0.3)
            end
        end)

        -- Use potion "p" loop (every 0.4 seconds)
        self.usePotionLoop2 = task.spawn(function()
            while self.Enabled do
                pcall(function()
                    usePotionP(tnet, self.Enabled)
                end)
                task.wait(0.4)
            end
        end)

        -- Use potion "o" loop (every 0.5 seconds)
        self.usePotionLoop3 = task.spawn(function()
            while self.Enabled do
                pcall(function()
                    usePotionO(tnet, self.Enabled)
                end)
                task.wait(0.5)
            end
        end)
    end

    function DupeWeaponsSystem:Stop()
        self.Enabled = false
        getgenv().KapaoConfig.DupeWeapons_Enabled = false
        if self.addPotionLoop then pcall(function() task.cancel(self.addPotionLoop) end) self.addPotionLoop = nil end
        if self.usePotionLoop1 then pcall(function() task.cancel(self.usePotionLoop1) end) self.usePotionLoop1 = nil end
        if self.usePotionLoop2 then pcall(function() task.cancel(self.usePotionLoop2) end) self.usePotionLoop2 = nil end
        if self.usePotionLoop3 then pcall(function() task.cancel(self.usePotionLoop3) end) self.usePotionLoop3 = nil end
    end


    Tabs.Misc:AddParagraph({
        Title = "⚠️ Dupe Weapons Warning",
        Content = "After duping, click 'Equip Best' in inventory every time"
    })

    -- Auto Sell Dupe Items System
    local AutoSellToggle = Tabs.Misc:AddToggle("AutoSellEnabled", {
        Title = "💰 Auto Sell Dupe",
        Description = "Sell 1 dupe item to let Script work",
        Default = false
    })

    -- Auto Sell System Variables
    local running = false
    local currentItemId = 0
    local autoSellEnabled = false
    local Event = nil

    -- ฟังก์ชันยิง Event ขายของ (เวอร์ชันอัปเดต)
    local function fireBurst()
        if currentItemId == 0 or not autoSellEnabled or not Event then
            return
        end

        pcall(function()
            for i = 1, 10 do
                Event:FireServer(
                    "B1",
                    math.random(30, 200),
                    {
                        currentItemId, -- ชิ้นที่ 1
                        currentItemId  -- ชิ้นที่ 2
                    }
                )
            end
        end)
    end

    -- Loop หลักในการขายของ
    local function sellingLoop()
        while running and autoSellEnabled do
            fireBurst()
            task.wait(0.5) -- หยุดรอ 0.5 วินาที ก่อนเริ่มยิงชุดใหม่
        end
    end

    -- Auto Sell Hook (only when enabled)
    local autoSellHookActive = false
    local originalNamecall

    local function setupAutoSellHook()
        if autoSellHookActive then return end
        
        -- หา Event ก่อน
        local rs = game:GetService('ReplicatedStorage')
        Event = rs:WaitForChild('TNetSent', 10)
        if not Event then 
            return 
        end
        
        autoSellHookActive = true

        local mt = getrawmetatable(game)
        originalNamecall = mt.__namecall
        setreadonly(mt, false)

        mt.__namecall = function(self, ...)
            local args = {...}
            local method = getnamecallmethod()

            -- Only hook when auto sell is enabled
            if autoSellEnabled and method == "FireServer" and self == Event then
                -- ตรวจสอบว่าเป็น Event ขายของ ("B0")
                if args[1] == "B0" and type(args[3]) == "table" then
                    local foundId
                    for _, value in pairs(args[3]) do
                        if type(value) == "number" then
                            foundId = value
                            break
                        end
                    end
                    
                    -- ถ้าเจอ ID ใหม่ที่ไม่เคยจำไว้
                    if foundId and currentItemId ~= foundId then
                        currentItemId = foundId
                        
                        -- เริ่ม loop อัตโนมัติถ้ายังไม่ทำงาน
                        if not running then
                            running = true
                            task.spawn(sellingLoop) -- เริ่ม loop การทำงาน
                        end
                    end
                end
            end

            return originalNamecall(self, ...)
        end

        setreadonly(mt, true)
    end

    local function removeAutoSellHook()
        if not autoSellHookActive then return end
        autoSellHookActive = false

        if originalNamecall then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            mt.__namecall = originalNamecall
            setreadonly(mt, true)
        end
    end

    AutoSellToggle:OnChanged(function()
        if Options.AutoSellEnabled.Value then
            getgenv().KapaoConfig.AutoSell_Enabled = true
            autoSellEnabled = true
            setupAutoSellHook()
            if currentItemId ~= 0 then
                running = true
                task.spawn(sellingLoop)
            end
        else
            getgenv().KapaoConfig.AutoSell_Enabled = false
            autoSellEnabled = false
            running = false
            removeAutoSellHook()
        end
    end)

    -- Fix Stuck Loading System
    local FixStuckLoadingSystem = {
        Enabled = false,
        placeId = 72607172956362
    }

    function FixStuckLoadingSystem:JoinRandomServer()
        
        local HttpService = game:GetService("HttpService")
        local TeleportService = game:GetService("TeleportService")
        local Players = game:GetService("Players")
        
        -- ตรวจสอบว่า Executor มีฟังก์ชัน request ตัวไหน
        local http_request = http_request or request or syn and syn.request
        
        if not http_request then
            return
        end
        
        pcall(function()
            -- ดึงข้อมูลเซิร์ฟเวอร์จาก Roblox API
            local servers = http_request({
                Url = "https://games.roblox.com/v1/games/" .. self.placeId .. "/servers/Public?sortOrder=Asc&limit=100",
                Method = "GET"
            })
            
            local data = HttpService:JSONDecode(servers.Body)
            
            if #data.data > 0 then
                -- สุ่มเลือกเซิร์ฟเวอร์จากลิสต์
                local randomServer = data.data[math.random(1, #data.data)]
                local jobId = randomServer.id
                
                TeleportService:TeleportToPlaceInstance(self.placeId, jobId, Players.LocalPlayer)
            end
        end)
    end

    function FixStuckLoadingSystem:Start()
        self.Enabled = true
        getgenv().KapaoConfig.FixStuckLoading_Enabled = true
        self:JoinRandomServer()
    end

    function FixStuckLoadingSystem:Stop()
        self.Enabled = false
        getgenv().KapaoConfig.FixStuckLoading_Enabled = false
    end

    -- Fix Stuck Loading Button
    local FixStuckLoadingButton = Tabs.Misc:AddButton({
        Title = "🔄 Fix Stuck In Loading",
        Description = "Join random server to fix loading",
        Callback = function()
            FixStuckLoadingSystem:JoinRandomServer()
        end
    })


    AutoHealToggle:OnChanged(function()
        if Options.AutoHealEnabled.Value then
            if not isAutoHealAllowed() then
                getgenv().KapaoConfig.AutoHeal_Enabled = false
                AutoHealSystem:Stop()
                return
            end
            AutoHealSystem:Start()
        else
            AutoHealSystem:Stop()
        end
    end)

    DupeWeaponsToggle:OnChanged(function()
        if Options.DupeWeaponsEnabled.Value then
            -- Dupe Weapons works everywhere, no placeid restriction needed
            DupeWeaponsSystem:Start()
        else
            DupeWeaponsSystem:Stop()
        end
    end)
end

-- Settings Tab Integration
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("KapaoHub")
SaveManager:SetFolder("KapaoHub/configs")

-- Add config info
Tabs.Settings:AddParagraph({
    Title = "📁 Configuration",
    Content = "Save and load your settings here"
})

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Add credits
Tabs.Settings:AddSection("Credits")
Tabs.Settings:AddParagraph({
    Title = "👑 Kapao Hub",
    Content = "Version: 1.0.1\nDeveloped with Coffee ;w;\n\nThank you for using Kapao Hub!"
})

-- Select first tab and show welcome notification
Window:SelectTab(1)

Fluent:Notify({
    Title = "☕ Kapao Hub",
    Content = "Successfully loaded! Enjoy Coffee ;w;",
    SubContent = "Version 1.0.1",
    Duration = 8
})

-- Auto load config if available
SaveManager:LoadAutoloadConfig()
